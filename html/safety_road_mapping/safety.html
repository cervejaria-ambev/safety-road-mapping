<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>safety_road_mapping.safety API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>safety_road_mapping.safety</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from folium import Map
from folium.features import GeoJson, GeoJsonTooltip
from folium.map import Icon, Marker
import numpy as np
from openrouteservice import client
from pandas.core.frame import DataFrame, Series
from pandas import Interval
from typeguard import typechecked
from typing import Union
import math
import pandas as pd
from geopy import distance
import unidecode
from colour import Color
import copy
from pathlib import Path
from dotenv import load_dotenv
import os


def generate_base_map(default_location: list = [-14, -50],
                      default_zoom_start: Union[int, float] = 4) -&gt; Map:
    &#34;&#34;&#34;
    Generates the basemap where the routes with their safety scores will be plotted.

    Parameters
    ----------
    default_location : list, optional
        Map&#39;s default location, by default [-14, -50]
    default_zoom_start : Union[int, float], optional
        Default zoom to be applied, by default 4

    Returns
    -------
    Map
        Map object to be used.
    &#34;&#34;&#34;
    return Map(location=default_location, control_scale=True, prefer_canvas=True,
               zoom_start=default_zoom_start, tiles=&#34;cartodbpositron&#34;,)


@typechecked
class SafetyMap(object):
    def __init__(self, accidents_data_file_path: str, start_point: tuple, end_point: tuple,
                 basemap: Map, sub_section_dist: float = 5., env_path: str = &#39;.env&#39;,
                 map_save_path: str = &#34;./maps/safety_map.html&#34;, color_value: int = None,
                 origin_name: str = &#39;&#39;, destination_name: str = &#39;&#39;):
        &#34;&#34;&#34;
        Initializes some important variables

        Parameters
        ----------
        accidents_data_file_path : str
            Path where the accidents .csv file is located in the disk.
        start_point : tuple
            Route start point in the format: (longitude, latitude)
        end_point : tuple
            Route end point in the format: (longitude, latitude)
        basemap : Map
            Map where the routes will be plotted
        sub_section_dist : float, optional
            Length of each subsection in the route in km, by default 5.
        env_path : str, optional
            Path to .env file, default &#34;.env&#34;
        map_save_path : str, optional
            Path where the .html file with the route map will be saved, by default
            &#34;./maps/safety_map.html&#34;
        color_value : int, optional
            Color to use on the icons in the map. This is special useful when you are plotting
            more routes in the same map. By default None
            You have to pass an integer between 0 and 18 as a dictionary key:
            {0: &#39;red&#39;, 1: &#39;lightred&#39;, 2: &#39;darkblue&#39;, 3: &#39;orange&#39;, 4: &#39;darkgreen&#39;,
             5: &#39;cadetblue&#39;, 6: &#39;purple&#39;, 7: &#39;black&#39;, 8: &#39;gray&#39;, 9: &#39;lightblue&#39;,
             10: &#39;beige&#39;, 11: &#39;lightgray&#39;, 12: &#39;lightgreen&#39;, 13: &#39;blue&#39;, 14: &#39;pink&#39;,
             15: &#39;darkpurple&#39;, 16: &#39;green&#39;, 17: &#39;white&#39;, 18: &#39;darkred&#39;}
        origin_name : str, optional
            Name given to the origin point, by default &#34;&#34;
        destination_name : str, optional
            Name given to the destination point, by default &#34;&#34;
        &#34;&#34;&#34;
        color_dict = {0: &#39;red&#39;, 1: &#39;lightred&#39;, 2: &#39;darkblue&#39;, 3: &#39;orange&#39;, 4: &#39;darkgreen&#39;,
                      5: &#39;cadetblue&#39;, 6: &#39;purple&#39;, 7: &#39;black&#39;, 8: &#39;gray&#39;, 9: &#39;lightblue&#39;,
                      10: &#39;beige&#39;, 11: &#39;lightgray&#39;, 12: &#39;lightgreen&#39;, 13: &#39;blue&#39;, 14: &#39;pink&#39;,
                      15: &#39;darkpurple&#39;, 16: &#39;green&#39;, 17: &#39;white&#39;, 18: &#39;darkred&#39;}
        dotenv_path = Path(env_path)
        load_dotenv(dotenv_path=dotenv_path)
        TOKEN = os.getenv(&#39;TOKEN&#39;)
        self.clnt = client.Client(key=TOKEN)
        self.base_map = basemap
        self.route = self._add_route_to_map(start_point, end_point)
        self.coor_df = self._gen_coordinates_df()
        self.accidents = self._treat_accidents_data(accidents_data_file_path)
        self.sub_section_dist = sub_section_dist
        self.map_save_path = map_save_path
        self.origin_name = origin_name
        self.destination_name = destination_name
        self.icon_color = color_dict.get(color_value)

    def _treat_accidents_data(self, path: str) -&gt; DataFrame:
        &#34;&#34;&#34;
        Method to open the csv file containing accidents information, treat the data and assign it
        to an attribute called accidents (DataFrame).

        Parameters
        ----------
        path : str
            The path where the file is located on the machine.

        Returns
        -------
        DataFrame
            Treated accidents DataFrame
        &#34;&#34;&#34;
        self.accidents = pd.read_csv(path, encoding=&#39;latin1&#39;, sep=&#39;;&#39;)
        self.accidents.loc[:, &#39;latitude&#39;] = (self.accidents[&#39;latitude&#39;].str.replace(&#39;,&#39;, &#39;.&#39;)
                                             .astype(&#39;float&#39;))
        self.accidents.loc[:, &#39;longitude&#39;] = (self.accidents[&#39;longitude&#39;].str.replace(&#39;,&#39;, &#39;.&#39;)
                                              .astype(&#39;float&#39;))
        l1 = list(self.accidents.query(&#39;longitude &gt; 0&#39;).index)
        l2 = list(self.accidents.query(&#39;longitude &lt; -75&#39;).index)
        self.accidents = self.accidents.drop(labels=l1+l2)
        self.accidents = self.accidents.drop_duplicates()
        self._filter_accident_data()
        return self.accidents

    def _add_route_to_map(self, start_point: tuple, end_point: tuple) -&gt; dict:
        &#34;&#34;&#34;
        Generates the route based on the start and end points.

        Parameters
        ----------
        start_point : tuple
            Start point format: (longitude, latitude)
        end_point : tuple
            End point format: (longitude, latitude)

        Returns
        -------
        dict
            A dictionary with route information to plot in a map
        &#34;&#34;&#34;
        request_params = {
            &#39;coordinates&#39;: [start_point, end_point],
            &#39;format_out&#39;: &#39;geojson&#39;,
            &#39;profile&#39;: &#39;driving-car&#39;,
            &#39;instructions&#39;: &#39;false&#39;,
            &#39;radiuses&#39;: [-1, -1],
            &#39;preference&#39;: &#39;recommended&#39;,
        }

        self.route = self.clnt.directions(**request_params)
        self.route_distance = (self.route[&#39;features&#39;][0][&#39;properties&#39;]
                               [&#39;summary&#39;][&#39;distance&#39;])
        self.trip_duration = (self.route[&#39;features&#39;][0][&#39;properties&#39;]
                              [&#39;summary&#39;][&#39;duration&#39;])
        return self.route

    def format_duration(self) -&gt; str:
        &#34;&#34;&#34;
        Format trip duration that is in second for hours, minutes and seconds

        Returns
        -------
        str
            String with the trip duration formated: HH:mm:ss
        &#34;&#34;&#34;
        if self.trip_duration is not None:
            duration_h = self.trip_duration / 3600
            hours = math.trunc(duration_h)
            duration_m = (duration_h - hours) * 60
            minutes = math.trunc(duration_m)
            seconds = math.trunc(((duration_m) - minutes) * 60)
            return f&#34;{hours:02}:{minutes:02}:{seconds:02}&#34;

    def _gen_coordinates_df(self) -&gt; DataFrame:
        &#34;&#34;&#34;
        Generate coordinates DataFrame based on route dictionary. This method gets the coordinates
        and extracts the latitude and longitude.
        It also calculates the distante between point in the route to generate the subsections and
        categorize them in groups. The coord_df contains the distance between coordinates to
        calculate the sections of the route.

        Returns
        -------
        DataFrame
            Coordinates DataFrame with the route&#39;s latitude and longitude, also it has the distance
            between the coordinate and the subsequent point. Based on the cumulative distance the
            route&#39;s subsections are created.
        &#34;&#34;&#34;
        coor = self.route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;coordinates&#39;]
        self.coor_df = pd.DataFrame(coor).rename(columns={0: &#39;olong&#39;, 1: &#39;olat&#39;})
        self.coor_df[[&#39;dlong&#39;, &#39;dlat&#39;]] = self.coor_df[[&#39;olong&#39;, &#39;olat&#39;]].shift(-1)
        self.coor_df[&#39;origin_tuple&#39;] = list(self.coor_df[[&#39;olat&#39;, &#39;olong&#39;]]
                                            .itertuples(index=False, name=None))
        self.coor_df[&#39;destination_tuple&#39;] = list(self.coor_df[[&#39;dlat&#39;, &#39;dlong&#39;]]
                                                 .itertuples(index=False, name=None))
        self.coor_df = self.coor_df.dropna()
        distance_list = []
        for _, row in self.coor_df.iterrows():
            origin = row.origin_tuple
            destination = row.destination_tuple
            distance_list.append(distance.distance(origin, destination).km)
        self.coor_df = self.coor_df.assign(route_dist=distance_list)
        self.coor_df = self.coor_df.assign(cum_sum=self.coor_df[&#39;route_dist&#39;]
                                           .cumsum())
        return self.coor_df

    def _gen_sections(self) -&gt; DataFrame:
        &#34;&#34;&#34;
        Method to create intervals with step `self.sub_section_dist`. Each group is one subsection of the
        route.

        Returns
        -------
        DataFrame
            sections DataFrame with the following information: coordinates&#39; latitude and longitude,
            cum_sum_min (the minimum distance of that route section), cum_sum_max (the maximum
            distance of that route section), sections (the first km and the last km included in that section,
            origin (section first coordinate), destination (section last coordinate))
        &#34;&#34;&#34;
        max_dis = self.coor_df[&#39;cum_sum&#39;].max()
        interval = pd.interval_range(start=0, end=max_dis + self.sub_section_dist,
                                     freq=self.sub_section_dist, closed=&#39;left&#39;)
        self.coor_df[&#39;sections&#39;] = pd.cut(self.coor_df[&#39;cum_sum&#39;], bins=interval)
        coor_sum_min = (self.coor_df.groupby(by=&#39;sections&#39;).agg({&#39;cum_sum&#39;: &#39;min&#39;})
                        .reset_index().rename(columns={&#39;cum_sum&#39;: &#39;cum_sum_min&#39;}))
        coor_sum_max = (self.coor_df.groupby(by=&#39;sections&#39;).agg({&#39;cum_sum&#39;: &#39;max&#39;})
                        .reset_index().rename(columns={&#39;cum_sum&#39;: &#39;cum_sum_max&#39;}))
        cols_min = [&#39;sections&#39;, &#39;cum_sum_min&#39;, &#39;olong&#39;, &#39;olat&#39;, &#39;origin_tuple&#39;]
        cols_max = [&#39;cum_sum_max&#39; if i == &#39;cum_sum_min&#39; else i for i in cols_min]
        coor_sum_min = (coor_sum_min.merge(self.coor_df, left_on=&#39;cum_sum_min&#39;,
                                           right_on=&#39;cum_sum&#39;)
                        .rename(columns={&#39;sections_x&#39;: &#39;sections&#39;})[cols_min])
        coor_sum_max = (coor_sum_max.merge(self.coor_df, left_on=&#39;cum_sum_max&#39;,
                                           right_on=&#39;cum_sum&#39;)
                        .rename(columns={&#39;sections_x&#39;: &#39;sections&#39;})[cols_max])
        rename_dict = {&#39;olong_x&#39;: &#39;olong&#39;,      &#39;olat_x&#39;: &#39;olat&#39;, &#39;origin_tuple_x&#39;: &#39;origin&#39;,
                       &#39;olong_y&#39;: &#39;dlong&#39;, &#39;olat_y&#39;: &#39;dlat&#39;, &#39;origin_tuple_y&#39;: &#39;destination&#39;}
        return coor_sum_min.merge(coor_sum_max, on=&#39;sections&#39;).rename(columns=rename_dict)

    @staticmethod
    def _normalize_string(string: str) -&gt; str:
        &#34;&#34;&#34;
        Normalizes strings removing accentuation, lowering them and joining them with underline (_)

        Parameters
        ----------
        string : str
            String to be normalized

        Returns
        -------
        str
            Normalized string
        &#34;&#34;&#34;
        string_no_accents = unidecode.unidecode(string)
        string_lower = string_no_accents.lower()
        string_without_space = string_lower.split(&#39; &#39;)
        return &#39;_&#39;.join(string_without_space)

    def _classes_accidents(self, accident: str) -&gt; int:
        &#34;&#34;&#34;
        Creates a score for the route&#39;s section. Those scores are arbitrary and can be tuned for what
        makes more sense

        Parameters
        ----------
        accident : str
            Accident class. &#39;sem_vitimas&#39; when there are no victims; &#39;com_vitimas_feridas&#39; when
            there are injured victims; &#39;com_vitimas_fatais&#39; when there are fatal victims.

        Returns
        -------
        int
            The accident score based on its class

        Raises
        ------
        Exception
            Raises an exception if an unexpected class is passed as a parameter.
        &#34;&#34;&#34;
        accident = self._normalize_string(accident)
        if accident == &#39;sem_vitimas&#39;:
            return 1
        elif accident == &#39;com_vitimas_feridas&#39;:
            return 5
        elif accident == &#39;com_vitimas_fatais&#39;:
            return 10
        else:
            raise Exception(&#34;Accident class doesn&#39;t mapped in the original dataset!&#34;)

    def _filter_accident_data(self) -&gt; DataFrame:
        &#34;&#34;&#34;
        Filters the accidents DataFrame based on the route coordinates. In other words, it gets the
        accidents points near the route only.

        Returns
        -------
        DataFrame
            Filtered accidents DataFrame
        &#34;&#34;&#34;
        min_olong = np.round(self.coor_df[&#39;olong&#39;].min(), 3)
        max_olong = np.round(self.coor_df[&#39;olong&#39;].max(), 3)
        min_olat = np.round(self.coor_df[&#39;olat&#39;].min(), 3)
        max_olat = np.round(self.coor_df[&#39;olat&#39;].max(), 3)
        query = (f&#39;({min_olat} &lt;= latitude &lt;= {max_olat}) and &#39;
                 f&#39;({min_olong} &lt;= longitude &lt;= {max_olong})&#39;)
        filtered = self.accidents.query(query)
        if not filtered.empty:
            self.accidents = filtered
        return self.accidents

    @staticmethod
    def _days_from_accident(df_date_col: Series) -&gt; Series:
        &#34;&#34;&#34;
        Calculates how many days has passed from the accident (based on the date of the last
        accident on dataset)

        Parameters
        ----------
        df_date_col : Series
            Accident dates column

        Returns
        -------
        Series
            Column with days from accident
        &#34;&#34;&#34;
        max_date = df_date_col.max()
        return (np.datetime64(max_date) - pd.to_datetime(df_date_col)).apply(lambda x: x.days)

    @staticmethod
    def _haversine(Olat: float, Olon: float, Dlat: Series, Dlon: Series) -&gt; Series:
        &#34;&#34;&#34;
        Calculates haversine distance. For more information look at:
        https://en.wikipedia.org/wiki/Haversine_formula

        Parameters
        ----------
        Olat : float
            Origin latitude
        Olon : float
            Origin longitude
        Dlat : Series
            Destiny latitude
        Dlon : Series
            Destiny longitude

        Returns
        -------
        Series
            Distance Series
        &#34;&#34;&#34;
        radius = 6371.  # km
        d_lat = np.radians(Dlat - Olat)
        d_lon = np.radians(Dlon - Olon)
        a = (np.sin(d_lat / 2.) * np.sin(d_lat / 2.) + np.cos(np.radians(Olat)) *
             np.cos(np.radians(Dlat)) * np.sin(d_lon / 2.) * np.sin(d_lon / 2.))
        c = 2. * np.arctan2(np.sqrt(a), np.sqrt(1. - a))
        return radius * c

    def _rank_subsections(self, df: DataFrame, flag: str) -&gt; DataFrame:
        &#34;&#34;&#34;
        Generates the score for each route subsection.

        Parameters
        ----------
        df : DataFrame
            DataFrame with coordinate, subsections and distances
        flag : str
            Flag to indicate if df rows represent each point in the route or if they are the route&#39;s
            subsections. Possible values are: &#39;point&#39; ou &#39;route&#39;

        Returns
        -------
        DataFrame
            DataFrame with the scores for the route&#39;s sections

        Raises
        ------
        Exception
            If the flag is not set to &#39;point&#39; or &#39;route&#39;
        &#34;&#34;&#34;
        last_val = int(df[&#39;sections&#39;].values[-1].right)
        rank_df_list = []
        for i in range(0, last_val, int(self.sub_section_dist)):
            interval = Interval(float(i), float(i + 5.0), closed=&#39;left&#39;)
            filtered_route = self.route_df[self.route_df[&#39;sections&#39;] == interval]
            rank_accidents = self.score_accidents.copy()
            distances_list = []
            for _, row in filtered_route.iterrows():
                distances = self._haversine(row[&#39;origin_tuple&#39;][0], row[&#39;origin_tuple&#39;][1],
                                            self.score_accidents.loc[:, &#39;latitude&#39;],
                                            self.score_accidents.loc[:, &#39;longitude&#39;])
                distances_list.append(distances)
            filtered_sections = df[df[&#39;sections&#39;] == interval]
            if flag == &#39;point&#39;:
                rank_df = filtered_sections[[&#39;sections&#39;, &#39;origin&#39;, &#39;destination&#39;]]
            elif flag == &#39;route&#39;:
                rank_df = filtered_sections[[&#39;sections&#39;, &#39;origin_tuple&#39;]]
            else:
                raise Exception(&#34;The flag used is not a valid option!!!&#34;)
            distances_list.append(rank_accidents[&#39;score&#39;])
            df_dist = pd.concat(distances_list, axis=1)
            rank = df_dist[(df_dist.iloc[:, :-1] &lt;= 1).sum(axis=1) &gt; 0][&#39;score&#39;].sum()
            rank_df = rank_df.assign(score=rank)
            rank_df_list.append(rank_df)
        return pd.concat(rank_df_list)

    def _getcolor(self, rank: float) -&gt; str:
        &#34;&#34;&#34;
        Generates the color for the subsection on the route based on its score.

        Parameters
        ----------
        rank : float
            Subsection&#39;s score

        Returns
        -------
        str
            Hexadecimal color or grey if the subsection has no score.
        &#34;&#34;&#34;
        max_score = int(np.ceil(self.final_rank_sections[&#39;score&#39;].max()))
        try:
            colors = list(Color(&#39;green&#39;).range_to(Color(&#39;red&#39;), max_score))
        except ValueError:
            return &#39;grey&#39;
        else:
            colors = [color.get_web() for color in colors]
            if rank == 0:
                return &#39;grey&#39;
            else:
                return colors[int(rank)]

    def _plot_route_score(self):
        &#34;&#34;&#34;
        Plots the subsections in the route on the map with different colors based on the the score
        of each subsection.
        &#34;&#34;&#34;
        rank_json = copy.deepcopy(self.route)
        properties = rank_json[&#39;features&#39;][0][&#39;properties&#39;]
        rank_json[&#39;features&#39;] = []
        last_val = int(self.sections_df[&#39;sections&#39;].values[-1].right)
        p_type = &#39;Feature&#39;
        for i in range(0, last_val, int(self.sub_section_dist)):
            interval = Interval(float(i), float(i) + 5.0, closed=&#39;left&#39;)
            subsection = self.final_rank_route[self.final_rank_route[&#39;sections&#39;] == interval]
            coor_list = subsection[&#39;origin_tuple&#39;].apply(lambda x: list(x[::-1])).to_list()
            bbox = self.route[&#39;bbox&#39;]
            id = str(i)
            rank_value = int(subsection[&#39;score&#39;].unique()[0])
            color = subsection[&#39;score&#39;].apply(self._getcolor).unique()[0]
            properties[&#39;score&#39;] = rank_value
            properties[&#39;color&#39;] = color
            append_dict = {&#39;bbox&#39;: bbox, &#39;type&#39;: p_type, &#39;properties&#39;: properties,
                           &#39;id&#39;: id, &#39;geometry&#39;: {}}
            append_dict[&#39;geometry&#39;][&#39;type&#39;] = self.route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;type&#39;]
            append_dict[&#39;geometry&#39;][&#39;coordinates&#39;] = coor_list
            rank_json[&#39;features&#39;].append(copy.deepcopy(append_dict))
        GeoJson(data=rank_json, overlay=True, smooth_factor=2,
                style_function=lambda x: {&#39;color&#39;: x[&#39;properties&#39;][&#39;color&#39;], &#39;weight&#39;: 5,
                                          &#39;fillOpacity&#39;: 1},
                highlight_function=lambda x: {&#39;weight&#39;: 10, &#39;color&#39;: x[&#39;properties&#39;][&#39;color&#39;]},
                tooltip=GeoJsonTooltip(fields=[&#39;score&#39;], aliases=[&#34;section risk&#39;s score: &#34;],
                                       labels=True, sticky=True,
                                       toLocaleString=True)).add_to(self.base_map)
        self.base_map.save(self.map_save_path)

    def _calculate_final_score(self) -&gt; float:
        &#34;&#34;&#34;
        Calculates the route&#39;s final score. To do this the scores of each subsection are summed and
        them divided by the route distance in kilometers. This is a way to normalize the final
        score. So, if two routes have the same summed score, the smaller one will have the higher
        final score.

        Returns
        -------
        float
            The final score calculated as stated above.
        &#34;&#34;&#34;
        sum_score = self.final_rank_sections[&#39;score&#39;].sum()
        self.score = sum_score / (self.route_distance / 1000)
        return self.score

    def _plot_final_score(self):
        &#34;&#34;&#34;
        Plots the final score on a marker on the map. To open the popup with the message, the user
        needs to click in the marker located approximately on the middle of the route.
        &#34;&#34;&#34;
        origin_label = &#39;: &#39; + self.origin_name if self.origin_name else &#39;&#39;
        destination_label = &#39;: &#39; + self.destination_name if self.destination_name else &#39;&#39;
        begin_color = self.icon_color or &#39;green&#39;
        end_color = self.icon_color or &#39;red&#39;
        score_color = self.icon_color or &#39;blue&#39;
        score = str(np.round(self.score, 2))
        popup = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:16px&#34;&gt;Route final score: &#39;
                 f&#39;&lt;b&gt;{score}&lt;/b&gt;&lt;/h3&gt;&#39;)
        tooltip = &#39;&lt;strong&gt;Click here to see route score&lt;/strong&gt;&#39;
        middle_pos = int(len(self.final_rank_route) / 2)
        marker_pos = self.final_rank_route.loc[middle_pos, &#39;origin_tuple&#39;]
        begin = self.final_rank_route.loc[0, &#39;origin_tuple&#39;]
        begin_formated = tuple(map(lambda coor: round(coor, 3), begin))
        end = self.final_rank_route.loc[len(self.final_rank_route) - 1, &#39;origin_tuple&#39;]
        end_formated = tuple(map(lambda coor: round(coor, 3), end))
        tooltip_begin = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:14px&#34;&gt;Route Begin Point&#39;
                         f&#39;&lt;b&gt;{origin_label}&lt;/b&gt;&lt;/h3&gt;&#39;)
        tooltip_end = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:14px&#34;&gt;Route End Point&#39;
                       f&#39;&lt;b&gt;{destination_label}&lt;/b&gt;&lt;/h3&gt;&#39;)
        (Marker(location=begin, tooltip=tooltip_begin, popup=f&#39;{begin_formated}&#39;,
                icon=Icon(color=begin_color, icon=&#39;fa-truck&#39;, prefix=&#39;fa&#39;)).add_to(self.base_map))
        (Marker(location=end, tooltip=tooltip_end, popup=f&#39;{end_formated}&#39;,
                icon=Icon(color=end_color, icon=&#39;fa-truck&#39;, prefix=&#39;fa&#39;)).add_to(self.base_map))
        (Marker(location=marker_pos, tooltip=tooltip, popup=popup,
                icon=Icon(color=score_color, icon=&#39;stats&#39;)).add_to(self.base_map))

    def _calculate_score_weight(self):
        &#34;&#34;&#34;
        Calculates the weight to multiply the class score based on how many days the accident
        occurred from the last date in the dataset. If the accident is recent the weight is near 1,
        if it occurred long time ago the weight is near 0.
        &#34;&#34;&#34;
        W_max = self.score_accidents[&#39;days_from_accident&#39;].max()
        W_min = self.score_accidents[&#39;days_from_accident&#39;].min()
        self.score_accidents[&#39;W&#39;] = ((W_max - self.score_accidents[&#39;days_from_accident&#39;]) /
                                     (W_max - W_min))
        self.score_accidents[&#39;score&#39;] = self.score_accidents[&#39;classes&#39;] * self.score_accidents[&#39;W&#39;]

    def path_risk_score(self, save_map: bool = False) -&gt; DataFrame:
        &#34;&#34;&#34;
        This method call the others above to generate the subsections, calculate the scores and plot
        all on the map

        Parameters
        ----------
        save_map : bool, optional
            If True, the map is save in .html format on the disk, by default False

        Returns
        -------
        DataFrame
            Final DataFrame with the score for each subsection on the route.
        &#34;&#34;&#34;
        self.score_accidents = self.accidents[[&#39;data_inversa&#39;, &#39;latitude&#39;, &#39;longitude&#39;,
                                               &#39;classificacao_acidente&#39;]]
        classes = self.score_accidents[&#39;classificacao_acidente&#39;].apply(self._classes_accidents)
        self.score_accidents = (self.score_accidents.assign(classes=classes)
                                .drop(columns=&#39;classificacao_acidente&#39;))
        days_from = self._days_from_accident(self.score_accidents[&#39;data_inversa&#39;])
        self.score_accidents[&#39;days_from_accident&#39;] = days_from
        self._calculate_score_weight()
        self.score_accidents[&#39;lat_long&#39;] = (list(self.score_accidents[[&#39;latitude&#39;, &#39;longitude&#39;]]
                                                 .itertuples(index=False, name=None)))
        self.sections_df = self._gen_sections()
        self.route_df = self.coor_df[[&#39;origin_tuple&#39;, &#39;destination_tuple&#39;, &#39;sections&#39;]]
        self.final_rank_sections = self._rank_subsections(self.sections_df, flag=&#39;point&#39;)
        self.final_rank_route = self._rank_subsections(self.coor_df, flag=&#39;route&#39;)
        self._calculate_final_score()
        print(f&#39;The final route score is {self.score:.2f}.&#39;)
        if save_map:
            print(&#39;Plotting route and final score on map...&#39;)
            self._plot_final_score()
            self._plot_route_score()
        return self.final_rank_sections


if __name__ == &#34;__main__&#34;:
    import time

    t0 = time.time()
    # Extrema: -22.864969298862736, -46.35471817331918
    # Nova Rio: -22.864365417300693, -43.60680685910165
    inicio = (-46.35471817331918, -22.864969298862736)
    fim = (-43.60680685910165, -22.864365417300693)
    data_path = &#34;accidents_data.csv&#34;
    s = SafetyMap(data_path, inicio, fim)
    s.path_risk_score(save_map=True)
    t1 = time.time()
    print(f&#39;Tempo necessário: {t1 - t0} segundos&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="safety_road_mapping.safety.generate_base_map"><code class="name flex">
<span>def <span class="ident">generate_base_map</span></span>(<span>default_location: list = [-14, -50], default_zoom_start: Union[int, float] = 4) ‑> folium.folium.Map</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the basemap where the routes with their safety scores will be plotted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>default_location</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Map's default location, by default [-14, -50]</dd>
<dt><strong><code>default_zoom_start</code></strong> :&ensp;<code>Union[int, float]</code>, optional</dt>
<dd>Default zoom to be applied, by default 4</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Map</code></dt>
<dd>Map object to be used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_base_map(default_location: list = [-14, -50],
                      default_zoom_start: Union[int, float] = 4) -&gt; Map:
    &#34;&#34;&#34;
    Generates the basemap where the routes with their safety scores will be plotted.

    Parameters
    ----------
    default_location : list, optional
        Map&#39;s default location, by default [-14, -50]
    default_zoom_start : Union[int, float], optional
        Default zoom to be applied, by default 4

    Returns
    -------
    Map
        Map object to be used.
    &#34;&#34;&#34;
    return Map(location=default_location, control_scale=True, prefer_canvas=True,
               zoom_start=default_zoom_start, tiles=&#34;cartodbpositron&#34;,)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="safety_road_mapping.safety.SafetyMap"><code class="flex name class">
<span>class <span class="ident">SafetyMap</span></span>
<span>(</span><span>accidents_data_file_path: str, start_point: tuple, end_point: tuple, basemap: folium.folium.Map, sub_section_dist: float = 5.0, env_path: str = '.env', map_save_path: str = './maps/safety_map.html', color_value: int = None, origin_name: str = '', destination_name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes some important variables</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>accidents_data_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path where the accidents .csv file is located in the disk.</dd>
<dt><strong><code>start_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Route start point in the format: (longitude, latitude)</dd>
<dt><strong><code>end_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Route end point in the format: (longitude, latitude)</dd>
<dt><strong><code>basemap</code></strong> :&ensp;<code>Map</code></dt>
<dd>Map where the routes will be plotted</dd>
<dt><strong><code>sub_section_dist</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Length of each subsection in the route in km, by default 5.</dd>
<dt><strong><code>env_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to .env file, default ".env"</dd>
<dt><strong><code>map_save_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path where the .html file with the route map will be saved, by default
"./maps/safety_map.html"</dd>
<dt><strong><code>color_value</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Color to use on the icons in the map. This is special useful when you are plotting
more routes in the same map. By default None
You have to pass an integer between 0 and 18 as a dictionary key:
{0: 'red', 1: 'lightred', 2: 'darkblue', 3: 'orange', 4: 'darkgreen',
5: 'cadetblue', 6: 'purple', 7: 'black', 8: 'gray', 9: 'lightblue',
10: 'beige', 11: 'lightgray', 12: 'lightgreen', 13: 'blue', 14: 'pink',
15: 'darkpurple', 16: 'green', 17: 'white', 18: 'darkred'}</dd>
<dt><strong><code>origin_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name given to the origin point, by default ""</dd>
<dt><strong><code>destination_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name given to the destination point, by default ""</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SafetyMap(object):
    def __init__(self, accidents_data_file_path: str, start_point: tuple, end_point: tuple,
                 basemap: Map, sub_section_dist: float = 5., env_path: str = &#39;.env&#39;,
                 map_save_path: str = &#34;./maps/safety_map.html&#34;, color_value: int = None,
                 origin_name: str = &#39;&#39;, destination_name: str = &#39;&#39;):
        &#34;&#34;&#34;
        Initializes some important variables

        Parameters
        ----------
        accidents_data_file_path : str
            Path where the accidents .csv file is located in the disk.
        start_point : tuple
            Route start point in the format: (longitude, latitude)
        end_point : tuple
            Route end point in the format: (longitude, latitude)
        basemap : Map
            Map where the routes will be plotted
        sub_section_dist : float, optional
            Length of each subsection in the route in km, by default 5.
        env_path : str, optional
            Path to .env file, default &#34;.env&#34;
        map_save_path : str, optional
            Path where the .html file with the route map will be saved, by default
            &#34;./maps/safety_map.html&#34;
        color_value : int, optional
            Color to use on the icons in the map. This is special useful when you are plotting
            more routes in the same map. By default None
            You have to pass an integer between 0 and 18 as a dictionary key:
            {0: &#39;red&#39;, 1: &#39;lightred&#39;, 2: &#39;darkblue&#39;, 3: &#39;orange&#39;, 4: &#39;darkgreen&#39;,
             5: &#39;cadetblue&#39;, 6: &#39;purple&#39;, 7: &#39;black&#39;, 8: &#39;gray&#39;, 9: &#39;lightblue&#39;,
             10: &#39;beige&#39;, 11: &#39;lightgray&#39;, 12: &#39;lightgreen&#39;, 13: &#39;blue&#39;, 14: &#39;pink&#39;,
             15: &#39;darkpurple&#39;, 16: &#39;green&#39;, 17: &#39;white&#39;, 18: &#39;darkred&#39;}
        origin_name : str, optional
            Name given to the origin point, by default &#34;&#34;
        destination_name : str, optional
            Name given to the destination point, by default &#34;&#34;
        &#34;&#34;&#34;
        color_dict = {0: &#39;red&#39;, 1: &#39;lightred&#39;, 2: &#39;darkblue&#39;, 3: &#39;orange&#39;, 4: &#39;darkgreen&#39;,
                      5: &#39;cadetblue&#39;, 6: &#39;purple&#39;, 7: &#39;black&#39;, 8: &#39;gray&#39;, 9: &#39;lightblue&#39;,
                      10: &#39;beige&#39;, 11: &#39;lightgray&#39;, 12: &#39;lightgreen&#39;, 13: &#39;blue&#39;, 14: &#39;pink&#39;,
                      15: &#39;darkpurple&#39;, 16: &#39;green&#39;, 17: &#39;white&#39;, 18: &#39;darkred&#39;}
        dotenv_path = Path(env_path)
        load_dotenv(dotenv_path=dotenv_path)
        TOKEN = os.getenv(&#39;TOKEN&#39;)
        self.clnt = client.Client(key=TOKEN)
        self.base_map = basemap
        self.route = self._add_route_to_map(start_point, end_point)
        self.coor_df = self._gen_coordinates_df()
        self.accidents = self._treat_accidents_data(accidents_data_file_path)
        self.sub_section_dist = sub_section_dist
        self.map_save_path = map_save_path
        self.origin_name = origin_name
        self.destination_name = destination_name
        self.icon_color = color_dict.get(color_value)

    def _treat_accidents_data(self, path: str) -&gt; DataFrame:
        &#34;&#34;&#34;
        Method to open the csv file containing accidents information, treat the data and assign it
        to an attribute called accidents (DataFrame).

        Parameters
        ----------
        path : str
            The path where the file is located on the machine.

        Returns
        -------
        DataFrame
            Treated accidents DataFrame
        &#34;&#34;&#34;
        self.accidents = pd.read_csv(path, encoding=&#39;latin1&#39;, sep=&#39;;&#39;)
        self.accidents.loc[:, &#39;latitude&#39;] = (self.accidents[&#39;latitude&#39;].str.replace(&#39;,&#39;, &#39;.&#39;)
                                             .astype(&#39;float&#39;))
        self.accidents.loc[:, &#39;longitude&#39;] = (self.accidents[&#39;longitude&#39;].str.replace(&#39;,&#39;, &#39;.&#39;)
                                              .astype(&#39;float&#39;))
        l1 = list(self.accidents.query(&#39;longitude &gt; 0&#39;).index)
        l2 = list(self.accidents.query(&#39;longitude &lt; -75&#39;).index)
        self.accidents = self.accidents.drop(labels=l1+l2)
        self.accidents = self.accidents.drop_duplicates()
        self._filter_accident_data()
        return self.accidents

    def _add_route_to_map(self, start_point: tuple, end_point: tuple) -&gt; dict:
        &#34;&#34;&#34;
        Generates the route based on the start and end points.

        Parameters
        ----------
        start_point : tuple
            Start point format: (longitude, latitude)
        end_point : tuple
            End point format: (longitude, latitude)

        Returns
        -------
        dict
            A dictionary with route information to plot in a map
        &#34;&#34;&#34;
        request_params = {
            &#39;coordinates&#39;: [start_point, end_point],
            &#39;format_out&#39;: &#39;geojson&#39;,
            &#39;profile&#39;: &#39;driving-car&#39;,
            &#39;instructions&#39;: &#39;false&#39;,
            &#39;radiuses&#39;: [-1, -1],
            &#39;preference&#39;: &#39;recommended&#39;,
        }

        self.route = self.clnt.directions(**request_params)
        self.route_distance = (self.route[&#39;features&#39;][0][&#39;properties&#39;]
                               [&#39;summary&#39;][&#39;distance&#39;])
        self.trip_duration = (self.route[&#39;features&#39;][0][&#39;properties&#39;]
                              [&#39;summary&#39;][&#39;duration&#39;])
        return self.route

    def format_duration(self) -&gt; str:
        &#34;&#34;&#34;
        Format trip duration that is in second for hours, minutes and seconds

        Returns
        -------
        str
            String with the trip duration formated: HH:mm:ss
        &#34;&#34;&#34;
        if self.trip_duration is not None:
            duration_h = self.trip_duration / 3600
            hours = math.trunc(duration_h)
            duration_m = (duration_h - hours) * 60
            minutes = math.trunc(duration_m)
            seconds = math.trunc(((duration_m) - minutes) * 60)
            return f&#34;{hours:02}:{minutes:02}:{seconds:02}&#34;

    def _gen_coordinates_df(self) -&gt; DataFrame:
        &#34;&#34;&#34;
        Generate coordinates DataFrame based on route dictionary. This method gets the coordinates
        and extracts the latitude and longitude.
        It also calculates the distante between point in the route to generate the subsections and
        categorize them in groups. The coord_df contains the distance between coordinates to
        calculate the sections of the route.

        Returns
        -------
        DataFrame
            Coordinates DataFrame with the route&#39;s latitude and longitude, also it has the distance
            between the coordinate and the subsequent point. Based on the cumulative distance the
            route&#39;s subsections are created.
        &#34;&#34;&#34;
        coor = self.route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;coordinates&#39;]
        self.coor_df = pd.DataFrame(coor).rename(columns={0: &#39;olong&#39;, 1: &#39;olat&#39;})
        self.coor_df[[&#39;dlong&#39;, &#39;dlat&#39;]] = self.coor_df[[&#39;olong&#39;, &#39;olat&#39;]].shift(-1)
        self.coor_df[&#39;origin_tuple&#39;] = list(self.coor_df[[&#39;olat&#39;, &#39;olong&#39;]]
                                            .itertuples(index=False, name=None))
        self.coor_df[&#39;destination_tuple&#39;] = list(self.coor_df[[&#39;dlat&#39;, &#39;dlong&#39;]]
                                                 .itertuples(index=False, name=None))
        self.coor_df = self.coor_df.dropna()
        distance_list = []
        for _, row in self.coor_df.iterrows():
            origin = row.origin_tuple
            destination = row.destination_tuple
            distance_list.append(distance.distance(origin, destination).km)
        self.coor_df = self.coor_df.assign(route_dist=distance_list)
        self.coor_df = self.coor_df.assign(cum_sum=self.coor_df[&#39;route_dist&#39;]
                                           .cumsum())
        return self.coor_df

    def _gen_sections(self) -&gt; DataFrame:
        &#34;&#34;&#34;
        Method to create intervals with step `self.sub_section_dist`. Each group is one subsection of the
        route.

        Returns
        -------
        DataFrame
            sections DataFrame with the following information: coordinates&#39; latitude and longitude,
            cum_sum_min (the minimum distance of that route section), cum_sum_max (the maximum
            distance of that route section), sections (the first km and the last km included in that section,
            origin (section first coordinate), destination (section last coordinate))
        &#34;&#34;&#34;
        max_dis = self.coor_df[&#39;cum_sum&#39;].max()
        interval = pd.interval_range(start=0, end=max_dis + self.sub_section_dist,
                                     freq=self.sub_section_dist, closed=&#39;left&#39;)
        self.coor_df[&#39;sections&#39;] = pd.cut(self.coor_df[&#39;cum_sum&#39;], bins=interval)
        coor_sum_min = (self.coor_df.groupby(by=&#39;sections&#39;).agg({&#39;cum_sum&#39;: &#39;min&#39;})
                        .reset_index().rename(columns={&#39;cum_sum&#39;: &#39;cum_sum_min&#39;}))
        coor_sum_max = (self.coor_df.groupby(by=&#39;sections&#39;).agg({&#39;cum_sum&#39;: &#39;max&#39;})
                        .reset_index().rename(columns={&#39;cum_sum&#39;: &#39;cum_sum_max&#39;}))
        cols_min = [&#39;sections&#39;, &#39;cum_sum_min&#39;, &#39;olong&#39;, &#39;olat&#39;, &#39;origin_tuple&#39;]
        cols_max = [&#39;cum_sum_max&#39; if i == &#39;cum_sum_min&#39; else i for i in cols_min]
        coor_sum_min = (coor_sum_min.merge(self.coor_df, left_on=&#39;cum_sum_min&#39;,
                                           right_on=&#39;cum_sum&#39;)
                        .rename(columns={&#39;sections_x&#39;: &#39;sections&#39;})[cols_min])
        coor_sum_max = (coor_sum_max.merge(self.coor_df, left_on=&#39;cum_sum_max&#39;,
                                           right_on=&#39;cum_sum&#39;)
                        .rename(columns={&#39;sections_x&#39;: &#39;sections&#39;})[cols_max])
        rename_dict = {&#39;olong_x&#39;: &#39;olong&#39;,      &#39;olat_x&#39;: &#39;olat&#39;, &#39;origin_tuple_x&#39;: &#39;origin&#39;,
                       &#39;olong_y&#39;: &#39;dlong&#39;, &#39;olat_y&#39;: &#39;dlat&#39;, &#39;origin_tuple_y&#39;: &#39;destination&#39;}
        return coor_sum_min.merge(coor_sum_max, on=&#39;sections&#39;).rename(columns=rename_dict)

    @staticmethod
    def _normalize_string(string: str) -&gt; str:
        &#34;&#34;&#34;
        Normalizes strings removing accentuation, lowering them and joining them with underline (_)

        Parameters
        ----------
        string : str
            String to be normalized

        Returns
        -------
        str
            Normalized string
        &#34;&#34;&#34;
        string_no_accents = unidecode.unidecode(string)
        string_lower = string_no_accents.lower()
        string_without_space = string_lower.split(&#39; &#39;)
        return &#39;_&#39;.join(string_without_space)

    def _classes_accidents(self, accident: str) -&gt; int:
        &#34;&#34;&#34;
        Creates a score for the route&#39;s section. Those scores are arbitrary and can be tuned for what
        makes more sense

        Parameters
        ----------
        accident : str
            Accident class. &#39;sem_vitimas&#39; when there are no victims; &#39;com_vitimas_feridas&#39; when
            there are injured victims; &#39;com_vitimas_fatais&#39; when there are fatal victims.

        Returns
        -------
        int
            The accident score based on its class

        Raises
        ------
        Exception
            Raises an exception if an unexpected class is passed as a parameter.
        &#34;&#34;&#34;
        accident = self._normalize_string(accident)
        if accident == &#39;sem_vitimas&#39;:
            return 1
        elif accident == &#39;com_vitimas_feridas&#39;:
            return 5
        elif accident == &#39;com_vitimas_fatais&#39;:
            return 10
        else:
            raise Exception(&#34;Accident class doesn&#39;t mapped in the original dataset!&#34;)

    def _filter_accident_data(self) -&gt; DataFrame:
        &#34;&#34;&#34;
        Filters the accidents DataFrame based on the route coordinates. In other words, it gets the
        accidents points near the route only.

        Returns
        -------
        DataFrame
            Filtered accidents DataFrame
        &#34;&#34;&#34;
        min_olong = np.round(self.coor_df[&#39;olong&#39;].min(), 3)
        max_olong = np.round(self.coor_df[&#39;olong&#39;].max(), 3)
        min_olat = np.round(self.coor_df[&#39;olat&#39;].min(), 3)
        max_olat = np.round(self.coor_df[&#39;olat&#39;].max(), 3)
        query = (f&#39;({min_olat} &lt;= latitude &lt;= {max_olat}) and &#39;
                 f&#39;({min_olong} &lt;= longitude &lt;= {max_olong})&#39;)
        filtered = self.accidents.query(query)
        if not filtered.empty:
            self.accidents = filtered
        return self.accidents

    @staticmethod
    def _days_from_accident(df_date_col: Series) -&gt; Series:
        &#34;&#34;&#34;
        Calculates how many days has passed from the accident (based on the date of the last
        accident on dataset)

        Parameters
        ----------
        df_date_col : Series
            Accident dates column

        Returns
        -------
        Series
            Column with days from accident
        &#34;&#34;&#34;
        max_date = df_date_col.max()
        return (np.datetime64(max_date) - pd.to_datetime(df_date_col)).apply(lambda x: x.days)

    @staticmethod
    def _haversine(Olat: float, Olon: float, Dlat: Series, Dlon: Series) -&gt; Series:
        &#34;&#34;&#34;
        Calculates haversine distance. For more information look at:
        https://en.wikipedia.org/wiki/Haversine_formula

        Parameters
        ----------
        Olat : float
            Origin latitude
        Olon : float
            Origin longitude
        Dlat : Series
            Destiny latitude
        Dlon : Series
            Destiny longitude

        Returns
        -------
        Series
            Distance Series
        &#34;&#34;&#34;
        radius = 6371.  # km
        d_lat = np.radians(Dlat - Olat)
        d_lon = np.radians(Dlon - Olon)
        a = (np.sin(d_lat / 2.) * np.sin(d_lat / 2.) + np.cos(np.radians(Olat)) *
             np.cos(np.radians(Dlat)) * np.sin(d_lon / 2.) * np.sin(d_lon / 2.))
        c = 2. * np.arctan2(np.sqrt(a), np.sqrt(1. - a))
        return radius * c

    def _rank_subsections(self, df: DataFrame, flag: str) -&gt; DataFrame:
        &#34;&#34;&#34;
        Generates the score for each route subsection.

        Parameters
        ----------
        df : DataFrame
            DataFrame with coordinate, subsections and distances
        flag : str
            Flag to indicate if df rows represent each point in the route or if they are the route&#39;s
            subsections. Possible values are: &#39;point&#39; ou &#39;route&#39;

        Returns
        -------
        DataFrame
            DataFrame with the scores for the route&#39;s sections

        Raises
        ------
        Exception
            If the flag is not set to &#39;point&#39; or &#39;route&#39;
        &#34;&#34;&#34;
        last_val = int(df[&#39;sections&#39;].values[-1].right)
        rank_df_list = []
        for i in range(0, last_val, int(self.sub_section_dist)):
            interval = Interval(float(i), float(i + 5.0), closed=&#39;left&#39;)
            filtered_route = self.route_df[self.route_df[&#39;sections&#39;] == interval]
            rank_accidents = self.score_accidents.copy()
            distances_list = []
            for _, row in filtered_route.iterrows():
                distances = self._haversine(row[&#39;origin_tuple&#39;][0], row[&#39;origin_tuple&#39;][1],
                                            self.score_accidents.loc[:, &#39;latitude&#39;],
                                            self.score_accidents.loc[:, &#39;longitude&#39;])
                distances_list.append(distances)
            filtered_sections = df[df[&#39;sections&#39;] == interval]
            if flag == &#39;point&#39;:
                rank_df = filtered_sections[[&#39;sections&#39;, &#39;origin&#39;, &#39;destination&#39;]]
            elif flag == &#39;route&#39;:
                rank_df = filtered_sections[[&#39;sections&#39;, &#39;origin_tuple&#39;]]
            else:
                raise Exception(&#34;The flag used is not a valid option!!!&#34;)
            distances_list.append(rank_accidents[&#39;score&#39;])
            df_dist = pd.concat(distances_list, axis=1)
            rank = df_dist[(df_dist.iloc[:, :-1] &lt;= 1).sum(axis=1) &gt; 0][&#39;score&#39;].sum()
            rank_df = rank_df.assign(score=rank)
            rank_df_list.append(rank_df)
        return pd.concat(rank_df_list)

    def _getcolor(self, rank: float) -&gt; str:
        &#34;&#34;&#34;
        Generates the color for the subsection on the route based on its score.

        Parameters
        ----------
        rank : float
            Subsection&#39;s score

        Returns
        -------
        str
            Hexadecimal color or grey if the subsection has no score.
        &#34;&#34;&#34;
        max_score = int(np.ceil(self.final_rank_sections[&#39;score&#39;].max()))
        try:
            colors = list(Color(&#39;green&#39;).range_to(Color(&#39;red&#39;), max_score))
        except ValueError:
            return &#39;grey&#39;
        else:
            colors = [color.get_web() for color in colors]
            if rank == 0:
                return &#39;grey&#39;
            else:
                return colors[int(rank)]

    def _plot_route_score(self):
        &#34;&#34;&#34;
        Plots the subsections in the route on the map with different colors based on the the score
        of each subsection.
        &#34;&#34;&#34;
        rank_json = copy.deepcopy(self.route)
        properties = rank_json[&#39;features&#39;][0][&#39;properties&#39;]
        rank_json[&#39;features&#39;] = []
        last_val = int(self.sections_df[&#39;sections&#39;].values[-1].right)
        p_type = &#39;Feature&#39;
        for i in range(0, last_val, int(self.sub_section_dist)):
            interval = Interval(float(i), float(i) + 5.0, closed=&#39;left&#39;)
            subsection = self.final_rank_route[self.final_rank_route[&#39;sections&#39;] == interval]
            coor_list = subsection[&#39;origin_tuple&#39;].apply(lambda x: list(x[::-1])).to_list()
            bbox = self.route[&#39;bbox&#39;]
            id = str(i)
            rank_value = int(subsection[&#39;score&#39;].unique()[0])
            color = subsection[&#39;score&#39;].apply(self._getcolor).unique()[0]
            properties[&#39;score&#39;] = rank_value
            properties[&#39;color&#39;] = color
            append_dict = {&#39;bbox&#39;: bbox, &#39;type&#39;: p_type, &#39;properties&#39;: properties,
                           &#39;id&#39;: id, &#39;geometry&#39;: {}}
            append_dict[&#39;geometry&#39;][&#39;type&#39;] = self.route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;type&#39;]
            append_dict[&#39;geometry&#39;][&#39;coordinates&#39;] = coor_list
            rank_json[&#39;features&#39;].append(copy.deepcopy(append_dict))
        GeoJson(data=rank_json, overlay=True, smooth_factor=2,
                style_function=lambda x: {&#39;color&#39;: x[&#39;properties&#39;][&#39;color&#39;], &#39;weight&#39;: 5,
                                          &#39;fillOpacity&#39;: 1},
                highlight_function=lambda x: {&#39;weight&#39;: 10, &#39;color&#39;: x[&#39;properties&#39;][&#39;color&#39;]},
                tooltip=GeoJsonTooltip(fields=[&#39;score&#39;], aliases=[&#34;section risk&#39;s score: &#34;],
                                       labels=True, sticky=True,
                                       toLocaleString=True)).add_to(self.base_map)
        self.base_map.save(self.map_save_path)

    def _calculate_final_score(self) -&gt; float:
        &#34;&#34;&#34;
        Calculates the route&#39;s final score. To do this the scores of each subsection are summed and
        them divided by the route distance in kilometers. This is a way to normalize the final
        score. So, if two routes have the same summed score, the smaller one will have the higher
        final score.

        Returns
        -------
        float
            The final score calculated as stated above.
        &#34;&#34;&#34;
        sum_score = self.final_rank_sections[&#39;score&#39;].sum()
        self.score = sum_score / (self.route_distance / 1000)
        return self.score

    def _plot_final_score(self):
        &#34;&#34;&#34;
        Plots the final score on a marker on the map. To open the popup with the message, the user
        needs to click in the marker located approximately on the middle of the route.
        &#34;&#34;&#34;
        origin_label = &#39;: &#39; + self.origin_name if self.origin_name else &#39;&#39;
        destination_label = &#39;: &#39; + self.destination_name if self.destination_name else &#39;&#39;
        begin_color = self.icon_color or &#39;green&#39;
        end_color = self.icon_color or &#39;red&#39;
        score_color = self.icon_color or &#39;blue&#39;
        score = str(np.round(self.score, 2))
        popup = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:16px&#34;&gt;Route final score: &#39;
                 f&#39;&lt;b&gt;{score}&lt;/b&gt;&lt;/h3&gt;&#39;)
        tooltip = &#39;&lt;strong&gt;Click here to see route score&lt;/strong&gt;&#39;
        middle_pos = int(len(self.final_rank_route) / 2)
        marker_pos = self.final_rank_route.loc[middle_pos, &#39;origin_tuple&#39;]
        begin = self.final_rank_route.loc[0, &#39;origin_tuple&#39;]
        begin_formated = tuple(map(lambda coor: round(coor, 3), begin))
        end = self.final_rank_route.loc[len(self.final_rank_route) - 1, &#39;origin_tuple&#39;]
        end_formated = tuple(map(lambda coor: round(coor, 3), end))
        tooltip_begin = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:14px&#34;&gt;Route Begin Point&#39;
                         f&#39;&lt;b&gt;{origin_label}&lt;/b&gt;&lt;/h3&gt;&#39;)
        tooltip_end = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:14px&#34;&gt;Route End Point&#39;
                       f&#39;&lt;b&gt;{destination_label}&lt;/b&gt;&lt;/h3&gt;&#39;)
        (Marker(location=begin, tooltip=tooltip_begin, popup=f&#39;{begin_formated}&#39;,
                icon=Icon(color=begin_color, icon=&#39;fa-truck&#39;, prefix=&#39;fa&#39;)).add_to(self.base_map))
        (Marker(location=end, tooltip=tooltip_end, popup=f&#39;{end_formated}&#39;,
                icon=Icon(color=end_color, icon=&#39;fa-truck&#39;, prefix=&#39;fa&#39;)).add_to(self.base_map))
        (Marker(location=marker_pos, tooltip=tooltip, popup=popup,
                icon=Icon(color=score_color, icon=&#39;stats&#39;)).add_to(self.base_map))

    def _calculate_score_weight(self):
        &#34;&#34;&#34;
        Calculates the weight to multiply the class score based on how many days the accident
        occurred from the last date in the dataset. If the accident is recent the weight is near 1,
        if it occurred long time ago the weight is near 0.
        &#34;&#34;&#34;
        W_max = self.score_accidents[&#39;days_from_accident&#39;].max()
        W_min = self.score_accidents[&#39;days_from_accident&#39;].min()
        self.score_accidents[&#39;W&#39;] = ((W_max - self.score_accidents[&#39;days_from_accident&#39;]) /
                                     (W_max - W_min))
        self.score_accidents[&#39;score&#39;] = self.score_accidents[&#39;classes&#39;] * self.score_accidents[&#39;W&#39;]

    def path_risk_score(self, save_map: bool = False) -&gt; DataFrame:
        &#34;&#34;&#34;
        This method call the others above to generate the subsections, calculate the scores and plot
        all on the map

        Parameters
        ----------
        save_map : bool, optional
            If True, the map is save in .html format on the disk, by default False

        Returns
        -------
        DataFrame
            Final DataFrame with the score for each subsection on the route.
        &#34;&#34;&#34;
        self.score_accidents = self.accidents[[&#39;data_inversa&#39;, &#39;latitude&#39;, &#39;longitude&#39;,
                                               &#39;classificacao_acidente&#39;]]
        classes = self.score_accidents[&#39;classificacao_acidente&#39;].apply(self._classes_accidents)
        self.score_accidents = (self.score_accidents.assign(classes=classes)
                                .drop(columns=&#39;classificacao_acidente&#39;))
        days_from = self._days_from_accident(self.score_accidents[&#39;data_inversa&#39;])
        self.score_accidents[&#39;days_from_accident&#39;] = days_from
        self._calculate_score_weight()
        self.score_accidents[&#39;lat_long&#39;] = (list(self.score_accidents[[&#39;latitude&#39;, &#39;longitude&#39;]]
                                                 .itertuples(index=False, name=None)))
        self.sections_df = self._gen_sections()
        self.route_df = self.coor_df[[&#39;origin_tuple&#39;, &#39;destination_tuple&#39;, &#39;sections&#39;]]
        self.final_rank_sections = self._rank_subsections(self.sections_df, flag=&#39;point&#39;)
        self.final_rank_route = self._rank_subsections(self.coor_df, flag=&#39;route&#39;)
        self._calculate_final_score()
        print(f&#39;The final route score is {self.score:.2f}.&#39;)
        if save_map:
            print(&#39;Plotting route and final score on map...&#39;)
            self._plot_final_score()
            self._plot_route_score()
        return self.final_rank_sections</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="safety_road_mapping.safety.SafetyMap._days_from_accident"><code class="name flex">
<span>def <span class="ident">_days_from_accident</span></span>(<span>df_date_col: pandas.core.series.Series) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates how many days has passed from the accident (based on the date of the last
accident on dataset)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df_date_col</code></strong> :&ensp;<code>Series</code></dt>
<dd>Accident dates column</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Series</code></dt>
<dd>Column with days from accident</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _days_from_accident(df_date_col: Series) -&gt; Series:
    &#34;&#34;&#34;
    Calculates how many days has passed from the accident (based on the date of the last
    accident on dataset)

    Parameters
    ----------
    df_date_col : Series
        Accident dates column

    Returns
    -------
    Series
        Column with days from accident
    &#34;&#34;&#34;
    max_date = df_date_col.max()
    return (np.datetime64(max_date) - pd.to_datetime(df_date_col)).apply(lambda x: x.days)</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._haversine"><code class="name flex">
<span>def <span class="ident">_haversine</span></span>(<span>Olat: float, Olon: float, Dlat: pandas.core.series.Series, Dlon: pandas.core.series.Series) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates haversine distance. For more information look at:
<a href="https://en.wikipedia.org/wiki/Haversine_formula">https://en.wikipedia.org/wiki/Haversine_formula</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Olat</code></strong> :&ensp;<code>float</code></dt>
<dd>Origin latitude</dd>
<dt><strong><code>Olon</code></strong> :&ensp;<code>float</code></dt>
<dd>Origin longitude</dd>
<dt><strong><code>Dlat</code></strong> :&ensp;<code>Series</code></dt>
<dd>Destiny latitude</dd>
<dt><strong><code>Dlon</code></strong> :&ensp;<code>Series</code></dt>
<dd>Destiny longitude</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Series</code></dt>
<dd>Distance Series</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _haversine(Olat: float, Olon: float, Dlat: Series, Dlon: Series) -&gt; Series:
    &#34;&#34;&#34;
    Calculates haversine distance. For more information look at:
    https://en.wikipedia.org/wiki/Haversine_formula

    Parameters
    ----------
    Olat : float
        Origin latitude
    Olon : float
        Origin longitude
    Dlat : Series
        Destiny latitude
    Dlon : Series
        Destiny longitude

    Returns
    -------
    Series
        Distance Series
    &#34;&#34;&#34;
    radius = 6371.  # km
    d_lat = np.radians(Dlat - Olat)
    d_lon = np.radians(Dlon - Olon)
    a = (np.sin(d_lat / 2.) * np.sin(d_lat / 2.) + np.cos(np.radians(Olat)) *
         np.cos(np.radians(Dlat)) * np.sin(d_lon / 2.) * np.sin(d_lon / 2.))
    c = 2. * np.arctan2(np.sqrt(a), np.sqrt(1. - a))
    return radius * c</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._normalize_string"><code class="name flex">
<span>def <span class="ident">_normalize_string</span></span>(<span>string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes strings removing accentuation, lowering them and joining them with underline (_)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>String to be normalized</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Normalized string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _normalize_string(string: str) -&gt; str:
    &#34;&#34;&#34;
    Normalizes strings removing accentuation, lowering them and joining them with underline (_)

    Parameters
    ----------
    string : str
        String to be normalized

    Returns
    -------
    str
        Normalized string
    &#34;&#34;&#34;
    string_no_accents = unidecode.unidecode(string)
    string_lower = string_no_accents.lower()
    string_without_space = string_lower.split(&#39; &#39;)
    return &#39;_&#39;.join(string_without_space)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="safety_road_mapping.safety.SafetyMap._add_route_to_map"><code class="name flex">
<span>def <span class="ident">_add_route_to_map</span></span>(<span>self, start_point: tuple, end_point: tuple) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the route based on the start and end points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Start point format: (longitude, latitude)</dd>
<dt><strong><code>end_point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>End point format: (longitude, latitude)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary with route information to plot in a map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _add_route_to_map(self, start_point: tuple, end_point: tuple) -&gt; dict:
    &#34;&#34;&#34;
    Generates the route based on the start and end points.

    Parameters
    ----------
    start_point : tuple
        Start point format: (longitude, latitude)
    end_point : tuple
        End point format: (longitude, latitude)

    Returns
    -------
    dict
        A dictionary with route information to plot in a map
    &#34;&#34;&#34;
    request_params = {
        &#39;coordinates&#39;: [start_point, end_point],
        &#39;format_out&#39;: &#39;geojson&#39;,
        &#39;profile&#39;: &#39;driving-car&#39;,
        &#39;instructions&#39;: &#39;false&#39;,
        &#39;radiuses&#39;: [-1, -1],
        &#39;preference&#39;: &#39;recommended&#39;,
    }

    self.route = self.clnt.directions(**request_params)
    self.route_distance = (self.route[&#39;features&#39;][0][&#39;properties&#39;]
                           [&#39;summary&#39;][&#39;distance&#39;])
    self.trip_duration = (self.route[&#39;features&#39;][0][&#39;properties&#39;]
                          [&#39;summary&#39;][&#39;duration&#39;])
    return self.route</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._calculate_final_score"><code class="name flex">
<span>def <span class="ident">_calculate_final_score</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the route's final score. To do this the scores of each subsection are summed and
them divided by the route distance in kilometers. This is a way to normalize the final
score. So, if two routes have the same summed score, the smaller one will have the higher
final score.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The final score calculated as stated above.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _calculate_final_score(self) -&gt; float:
    &#34;&#34;&#34;
    Calculates the route&#39;s final score. To do this the scores of each subsection are summed and
    them divided by the route distance in kilometers. This is a way to normalize the final
    score. So, if two routes have the same summed score, the smaller one will have the higher
    final score.

    Returns
    -------
    float
        The final score calculated as stated above.
    &#34;&#34;&#34;
    sum_score = self.final_rank_sections[&#39;score&#39;].sum()
    self.score = sum_score / (self.route_distance / 1000)
    return self.score</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._calculate_score_weight"><code class="name flex">
<span>def <span class="ident">_calculate_score_weight</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the weight to multiply the class score based on how many days the accident
occurred from the last date in the dataset. If the accident is recent the weight is near 1,
if it occurred long time ago the weight is near 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _calculate_score_weight(self):
    &#34;&#34;&#34;
    Calculates the weight to multiply the class score based on how many days the accident
    occurred from the last date in the dataset. If the accident is recent the weight is near 1,
    if it occurred long time ago the weight is near 0.
    &#34;&#34;&#34;
    W_max = self.score_accidents[&#39;days_from_accident&#39;].max()
    W_min = self.score_accidents[&#39;days_from_accident&#39;].min()
    self.score_accidents[&#39;W&#39;] = ((W_max - self.score_accidents[&#39;days_from_accident&#39;]) /
                                 (W_max - W_min))
    self.score_accidents[&#39;score&#39;] = self.score_accidents[&#39;classes&#39;] * self.score_accidents[&#39;W&#39;]</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._classes_accidents"><code class="name flex">
<span>def <span class="ident">_classes_accidents</span></span>(<span>self, accident: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a score for the route's section. Those scores are arbitrary and can be tuned for what
makes more sense</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>accident</code></strong> :&ensp;<code>str</code></dt>
<dd>Accident class. 'sem_vitimas' when there are no victims; 'com_vitimas_feridas' when
there are injured victims; 'com_vitimas_fatais' when there are fatal victims.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The accident score based on its class</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Raises an exception if an unexpected class is passed as a parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _classes_accidents(self, accident: str) -&gt; int:
    &#34;&#34;&#34;
    Creates a score for the route&#39;s section. Those scores are arbitrary and can be tuned for what
    makes more sense

    Parameters
    ----------
    accident : str
        Accident class. &#39;sem_vitimas&#39; when there are no victims; &#39;com_vitimas_feridas&#39; when
        there are injured victims; &#39;com_vitimas_fatais&#39; when there are fatal victims.

    Returns
    -------
    int
        The accident score based on its class

    Raises
    ------
    Exception
        Raises an exception if an unexpected class is passed as a parameter.
    &#34;&#34;&#34;
    accident = self._normalize_string(accident)
    if accident == &#39;sem_vitimas&#39;:
        return 1
    elif accident == &#39;com_vitimas_feridas&#39;:
        return 5
    elif accident == &#39;com_vitimas_fatais&#39;:
        return 10
    else:
        raise Exception(&#34;Accident class doesn&#39;t mapped in the original dataset!&#34;)</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._filter_accident_data"><code class="name flex">
<span>def <span class="ident">_filter_accident_data</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Filters the accidents DataFrame based on the route coordinates. In other words, it gets the
accidents points near the route only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Filtered accidents DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _filter_accident_data(self) -&gt; DataFrame:
    &#34;&#34;&#34;
    Filters the accidents DataFrame based on the route coordinates. In other words, it gets the
    accidents points near the route only.

    Returns
    -------
    DataFrame
        Filtered accidents DataFrame
    &#34;&#34;&#34;
    min_olong = np.round(self.coor_df[&#39;olong&#39;].min(), 3)
    max_olong = np.round(self.coor_df[&#39;olong&#39;].max(), 3)
    min_olat = np.round(self.coor_df[&#39;olat&#39;].min(), 3)
    max_olat = np.round(self.coor_df[&#39;olat&#39;].max(), 3)
    query = (f&#39;({min_olat} &lt;= latitude &lt;= {max_olat}) and &#39;
             f&#39;({min_olong} &lt;= longitude &lt;= {max_olong})&#39;)
    filtered = self.accidents.query(query)
    if not filtered.empty:
        self.accidents = filtered
    return self.accidents</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._gen_coordinates_df"><code class="name flex">
<span>def <span class="ident">_gen_coordinates_df</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate coordinates DataFrame based on route dictionary. This method gets the coordinates
and extracts the latitude and longitude.
It also calculates the distante between point in the route to generate the subsections and
categorize them in groups. The coord_df contains the distance between coordinates to
calculate the sections of the route.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Coordinates DataFrame with the route's latitude and longitude, also it has the distance
between the coordinate and the subsequent point. Based on the cumulative distance the
route's subsections are created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _gen_coordinates_df(self) -&gt; DataFrame:
    &#34;&#34;&#34;
    Generate coordinates DataFrame based on route dictionary. This method gets the coordinates
    and extracts the latitude and longitude.
    It also calculates the distante between point in the route to generate the subsections and
    categorize them in groups. The coord_df contains the distance between coordinates to
    calculate the sections of the route.

    Returns
    -------
    DataFrame
        Coordinates DataFrame with the route&#39;s latitude and longitude, also it has the distance
        between the coordinate and the subsequent point. Based on the cumulative distance the
        route&#39;s subsections are created.
    &#34;&#34;&#34;
    coor = self.route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;coordinates&#39;]
    self.coor_df = pd.DataFrame(coor).rename(columns={0: &#39;olong&#39;, 1: &#39;olat&#39;})
    self.coor_df[[&#39;dlong&#39;, &#39;dlat&#39;]] = self.coor_df[[&#39;olong&#39;, &#39;olat&#39;]].shift(-1)
    self.coor_df[&#39;origin_tuple&#39;] = list(self.coor_df[[&#39;olat&#39;, &#39;olong&#39;]]
                                        .itertuples(index=False, name=None))
    self.coor_df[&#39;destination_tuple&#39;] = list(self.coor_df[[&#39;dlat&#39;, &#39;dlong&#39;]]
                                             .itertuples(index=False, name=None))
    self.coor_df = self.coor_df.dropna()
    distance_list = []
    for _, row in self.coor_df.iterrows():
        origin = row.origin_tuple
        destination = row.destination_tuple
        distance_list.append(distance.distance(origin, destination).km)
    self.coor_df = self.coor_df.assign(route_dist=distance_list)
    self.coor_df = self.coor_df.assign(cum_sum=self.coor_df[&#39;route_dist&#39;]
                                       .cumsum())
    return self.coor_df</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._gen_sections"><code class="name flex">
<span>def <span class="ident">_gen_sections</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Method to create intervals with step <code>self.sub_section_dist</code>. Each group is one subsection of the
route.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>sections DataFrame with the following information: coordinates' latitude and longitude,
cum_sum_min (the minimum distance of that route section), cum_sum_max (the maximum
distance of that route section), sections (the first km and the last km included in that section,
origin (section first coordinate), destination (section last coordinate))</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _gen_sections(self) -&gt; DataFrame:
    &#34;&#34;&#34;
    Method to create intervals with step `self.sub_section_dist`. Each group is one subsection of the
    route.

    Returns
    -------
    DataFrame
        sections DataFrame with the following information: coordinates&#39; latitude and longitude,
        cum_sum_min (the minimum distance of that route section), cum_sum_max (the maximum
        distance of that route section), sections (the first km and the last km included in that section,
        origin (section first coordinate), destination (section last coordinate))
    &#34;&#34;&#34;
    max_dis = self.coor_df[&#39;cum_sum&#39;].max()
    interval = pd.interval_range(start=0, end=max_dis + self.sub_section_dist,
                                 freq=self.sub_section_dist, closed=&#39;left&#39;)
    self.coor_df[&#39;sections&#39;] = pd.cut(self.coor_df[&#39;cum_sum&#39;], bins=interval)
    coor_sum_min = (self.coor_df.groupby(by=&#39;sections&#39;).agg({&#39;cum_sum&#39;: &#39;min&#39;})
                    .reset_index().rename(columns={&#39;cum_sum&#39;: &#39;cum_sum_min&#39;}))
    coor_sum_max = (self.coor_df.groupby(by=&#39;sections&#39;).agg({&#39;cum_sum&#39;: &#39;max&#39;})
                    .reset_index().rename(columns={&#39;cum_sum&#39;: &#39;cum_sum_max&#39;}))
    cols_min = [&#39;sections&#39;, &#39;cum_sum_min&#39;, &#39;olong&#39;, &#39;olat&#39;, &#39;origin_tuple&#39;]
    cols_max = [&#39;cum_sum_max&#39; if i == &#39;cum_sum_min&#39; else i for i in cols_min]
    coor_sum_min = (coor_sum_min.merge(self.coor_df, left_on=&#39;cum_sum_min&#39;,
                                       right_on=&#39;cum_sum&#39;)
                    .rename(columns={&#39;sections_x&#39;: &#39;sections&#39;})[cols_min])
    coor_sum_max = (coor_sum_max.merge(self.coor_df, left_on=&#39;cum_sum_max&#39;,
                                       right_on=&#39;cum_sum&#39;)
                    .rename(columns={&#39;sections_x&#39;: &#39;sections&#39;})[cols_max])
    rename_dict = {&#39;olong_x&#39;: &#39;olong&#39;,      &#39;olat_x&#39;: &#39;olat&#39;, &#39;origin_tuple_x&#39;: &#39;origin&#39;,
                   &#39;olong_y&#39;: &#39;dlong&#39;, &#39;olat_y&#39;: &#39;dlat&#39;, &#39;origin_tuple_y&#39;: &#39;destination&#39;}
    return coor_sum_min.merge(coor_sum_max, on=&#39;sections&#39;).rename(columns=rename_dict)</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._getcolor"><code class="name flex">
<span>def <span class="ident">_getcolor</span></span>(<span>self, rank: float) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the color for the subsection on the route based on its score.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rank</code></strong> :&ensp;<code>float</code></dt>
<dd>Subsection's score</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hexadecimal color or grey if the subsection has no score.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _getcolor(self, rank: float) -&gt; str:
    &#34;&#34;&#34;
    Generates the color for the subsection on the route based on its score.

    Parameters
    ----------
    rank : float
        Subsection&#39;s score

    Returns
    -------
    str
        Hexadecimal color or grey if the subsection has no score.
    &#34;&#34;&#34;
    max_score = int(np.ceil(self.final_rank_sections[&#39;score&#39;].max()))
    try:
        colors = list(Color(&#39;green&#39;).range_to(Color(&#39;red&#39;), max_score))
    except ValueError:
        return &#39;grey&#39;
    else:
        colors = [color.get_web() for color in colors]
        if rank == 0:
            return &#39;grey&#39;
        else:
            return colors[int(rank)]</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._plot_final_score"><code class="name flex">
<span>def <span class="ident">_plot_final_score</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the final score on a marker on the map. To open the popup with the message, the user
needs to click in the marker located approximately on the middle of the route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_final_score(self):
    &#34;&#34;&#34;
    Plots the final score on a marker on the map. To open the popup with the message, the user
    needs to click in the marker located approximately on the middle of the route.
    &#34;&#34;&#34;
    origin_label = &#39;: &#39; + self.origin_name if self.origin_name else &#39;&#39;
    destination_label = &#39;: &#39; + self.destination_name if self.destination_name else &#39;&#39;
    begin_color = self.icon_color or &#39;green&#39;
    end_color = self.icon_color or &#39;red&#39;
    score_color = self.icon_color or &#39;blue&#39;
    score = str(np.round(self.score, 2))
    popup = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:16px&#34;&gt;Route final score: &#39;
             f&#39;&lt;b&gt;{score}&lt;/b&gt;&lt;/h3&gt;&#39;)
    tooltip = &#39;&lt;strong&gt;Click here to see route score&lt;/strong&gt;&#39;
    middle_pos = int(len(self.final_rank_route) / 2)
    marker_pos = self.final_rank_route.loc[middle_pos, &#39;origin_tuple&#39;]
    begin = self.final_rank_route.loc[0, &#39;origin_tuple&#39;]
    begin_formated = tuple(map(lambda coor: round(coor, 3), begin))
    end = self.final_rank_route.loc[len(self.final_rank_route) - 1, &#39;origin_tuple&#39;]
    end_formated = tuple(map(lambda coor: round(coor, 3), end))
    tooltip_begin = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:14px&#34;&gt;Route Begin Point&#39;
                     f&#39;&lt;b&gt;{origin_label}&lt;/b&gt;&lt;/h3&gt;&#39;)
    tooltip_end = (&#39;&lt;h3 align=&#34;center&#34; style=&#34;font-size:14px&#34;&gt;Route End Point&#39;
                   f&#39;&lt;b&gt;{destination_label}&lt;/b&gt;&lt;/h3&gt;&#39;)
    (Marker(location=begin, tooltip=tooltip_begin, popup=f&#39;{begin_formated}&#39;,
            icon=Icon(color=begin_color, icon=&#39;fa-truck&#39;, prefix=&#39;fa&#39;)).add_to(self.base_map))
    (Marker(location=end, tooltip=tooltip_end, popup=f&#39;{end_formated}&#39;,
            icon=Icon(color=end_color, icon=&#39;fa-truck&#39;, prefix=&#39;fa&#39;)).add_to(self.base_map))
    (Marker(location=marker_pos, tooltip=tooltip, popup=popup,
            icon=Icon(color=score_color, icon=&#39;stats&#39;)).add_to(self.base_map))</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._plot_route_score"><code class="name flex">
<span>def <span class="ident">_plot_route_score</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the subsections in the route on the map with different colors based on the the score
of each subsection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_route_score(self):
    &#34;&#34;&#34;
    Plots the subsections in the route on the map with different colors based on the the score
    of each subsection.
    &#34;&#34;&#34;
    rank_json = copy.deepcopy(self.route)
    properties = rank_json[&#39;features&#39;][0][&#39;properties&#39;]
    rank_json[&#39;features&#39;] = []
    last_val = int(self.sections_df[&#39;sections&#39;].values[-1].right)
    p_type = &#39;Feature&#39;
    for i in range(0, last_val, int(self.sub_section_dist)):
        interval = Interval(float(i), float(i) + 5.0, closed=&#39;left&#39;)
        subsection = self.final_rank_route[self.final_rank_route[&#39;sections&#39;] == interval]
        coor_list = subsection[&#39;origin_tuple&#39;].apply(lambda x: list(x[::-1])).to_list()
        bbox = self.route[&#39;bbox&#39;]
        id = str(i)
        rank_value = int(subsection[&#39;score&#39;].unique()[0])
        color = subsection[&#39;score&#39;].apply(self._getcolor).unique()[0]
        properties[&#39;score&#39;] = rank_value
        properties[&#39;color&#39;] = color
        append_dict = {&#39;bbox&#39;: bbox, &#39;type&#39;: p_type, &#39;properties&#39;: properties,
                       &#39;id&#39;: id, &#39;geometry&#39;: {}}
        append_dict[&#39;geometry&#39;][&#39;type&#39;] = self.route[&#39;features&#39;][0][&#39;geometry&#39;][&#39;type&#39;]
        append_dict[&#39;geometry&#39;][&#39;coordinates&#39;] = coor_list
        rank_json[&#39;features&#39;].append(copy.deepcopy(append_dict))
    GeoJson(data=rank_json, overlay=True, smooth_factor=2,
            style_function=lambda x: {&#39;color&#39;: x[&#39;properties&#39;][&#39;color&#39;], &#39;weight&#39;: 5,
                                      &#39;fillOpacity&#39;: 1},
            highlight_function=lambda x: {&#39;weight&#39;: 10, &#39;color&#39;: x[&#39;properties&#39;][&#39;color&#39;]},
            tooltip=GeoJsonTooltip(fields=[&#39;score&#39;], aliases=[&#34;section risk&#39;s score: &#34;],
                                   labels=True, sticky=True,
                                   toLocaleString=True)).add_to(self.base_map)
    self.base_map.save(self.map_save_path)</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._rank_subsections"><code class="name flex">
<span>def <span class="ident">_rank_subsections</span></span>(<span>self, df: pandas.core.frame.DataFrame, flag: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the score for each route subsection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>DataFrame with coordinate, subsections and distances</dd>
<dt><strong><code>flag</code></strong> :&ensp;<code>str</code></dt>
<dd>Flag to indicate if df rows represent each point in the route or if they are the route's
subsections. Possible values are: 'point' ou 'route'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>DataFrame with the scores for the route's sections</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the flag is not set to 'point' or 'route'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _rank_subsections(self, df: DataFrame, flag: str) -&gt; DataFrame:
    &#34;&#34;&#34;
    Generates the score for each route subsection.

    Parameters
    ----------
    df : DataFrame
        DataFrame with coordinate, subsections and distances
    flag : str
        Flag to indicate if df rows represent each point in the route or if they are the route&#39;s
        subsections. Possible values are: &#39;point&#39; ou &#39;route&#39;

    Returns
    -------
    DataFrame
        DataFrame with the scores for the route&#39;s sections

    Raises
    ------
    Exception
        If the flag is not set to &#39;point&#39; or &#39;route&#39;
    &#34;&#34;&#34;
    last_val = int(df[&#39;sections&#39;].values[-1].right)
    rank_df_list = []
    for i in range(0, last_val, int(self.sub_section_dist)):
        interval = Interval(float(i), float(i + 5.0), closed=&#39;left&#39;)
        filtered_route = self.route_df[self.route_df[&#39;sections&#39;] == interval]
        rank_accidents = self.score_accidents.copy()
        distances_list = []
        for _, row in filtered_route.iterrows():
            distances = self._haversine(row[&#39;origin_tuple&#39;][0], row[&#39;origin_tuple&#39;][1],
                                        self.score_accidents.loc[:, &#39;latitude&#39;],
                                        self.score_accidents.loc[:, &#39;longitude&#39;])
            distances_list.append(distances)
        filtered_sections = df[df[&#39;sections&#39;] == interval]
        if flag == &#39;point&#39;:
            rank_df = filtered_sections[[&#39;sections&#39;, &#39;origin&#39;, &#39;destination&#39;]]
        elif flag == &#39;route&#39;:
            rank_df = filtered_sections[[&#39;sections&#39;, &#39;origin_tuple&#39;]]
        else:
            raise Exception(&#34;The flag used is not a valid option!!!&#34;)
        distances_list.append(rank_accidents[&#39;score&#39;])
        df_dist = pd.concat(distances_list, axis=1)
        rank = df_dist[(df_dist.iloc[:, :-1] &lt;= 1).sum(axis=1) &gt; 0][&#39;score&#39;].sum()
        rank_df = rank_df.assign(score=rank)
        rank_df_list.append(rank_df)
    return pd.concat(rank_df_list)</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap._treat_accidents_data"><code class="name flex">
<span>def <span class="ident">_treat_accidents_data</span></span>(<span>self, path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Method to open the csv file containing accidents information, treat the data and assign it
to an attribute called accidents (DataFrame).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path where the file is located on the machine.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Treated accidents DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _treat_accidents_data(self, path: str) -&gt; DataFrame:
    &#34;&#34;&#34;
    Method to open the csv file containing accidents information, treat the data and assign it
    to an attribute called accidents (DataFrame).

    Parameters
    ----------
    path : str
        The path where the file is located on the machine.

    Returns
    -------
    DataFrame
        Treated accidents DataFrame
    &#34;&#34;&#34;
    self.accidents = pd.read_csv(path, encoding=&#39;latin1&#39;, sep=&#39;;&#39;)
    self.accidents.loc[:, &#39;latitude&#39;] = (self.accidents[&#39;latitude&#39;].str.replace(&#39;,&#39;, &#39;.&#39;)
                                         .astype(&#39;float&#39;))
    self.accidents.loc[:, &#39;longitude&#39;] = (self.accidents[&#39;longitude&#39;].str.replace(&#39;,&#39;, &#39;.&#39;)
                                          .astype(&#39;float&#39;))
    l1 = list(self.accidents.query(&#39;longitude &gt; 0&#39;).index)
    l2 = list(self.accidents.query(&#39;longitude &lt; -75&#39;).index)
    self.accidents = self.accidents.drop(labels=l1+l2)
    self.accidents = self.accidents.drop_duplicates()
    self._filter_accident_data()
    return self.accidents</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap.format_duration"><code class="name flex">
<span>def <span class="ident">format_duration</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format trip duration that is in second for hours, minutes and seconds</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>String with the trip duration formated: HH:mm:ss</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_duration(self) -&gt; str:
    &#34;&#34;&#34;
    Format trip duration that is in second for hours, minutes and seconds

    Returns
    -------
    str
        String with the trip duration formated: HH:mm:ss
    &#34;&#34;&#34;
    if self.trip_duration is not None:
        duration_h = self.trip_duration / 3600
        hours = math.trunc(duration_h)
        duration_m = (duration_h - hours) * 60
        minutes = math.trunc(duration_m)
        seconds = math.trunc(((duration_m) - minutes) * 60)
        return f&#34;{hours:02}:{minutes:02}:{seconds:02}&#34;</code></pre>
</details>
</dd>
<dt id="safety_road_mapping.safety.SafetyMap.path_risk_score"><code class="name flex">
<span>def <span class="ident">path_risk_score</span></span>(<span>self, save_map: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>This method call the others above to generate the subsections, calculate the scores and plot
all on the map</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>save_map</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the map is save in .html format on the disk, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Final DataFrame with the score for each subsection on the route.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_risk_score(self, save_map: bool = False) -&gt; DataFrame:
    &#34;&#34;&#34;
    This method call the others above to generate the subsections, calculate the scores and plot
    all on the map

    Parameters
    ----------
    save_map : bool, optional
        If True, the map is save in .html format on the disk, by default False

    Returns
    -------
    DataFrame
        Final DataFrame with the score for each subsection on the route.
    &#34;&#34;&#34;
    self.score_accidents = self.accidents[[&#39;data_inversa&#39;, &#39;latitude&#39;, &#39;longitude&#39;,
                                           &#39;classificacao_acidente&#39;]]
    classes = self.score_accidents[&#39;classificacao_acidente&#39;].apply(self._classes_accidents)
    self.score_accidents = (self.score_accidents.assign(classes=classes)
                            .drop(columns=&#39;classificacao_acidente&#39;))
    days_from = self._days_from_accident(self.score_accidents[&#39;data_inversa&#39;])
    self.score_accidents[&#39;days_from_accident&#39;] = days_from
    self._calculate_score_weight()
    self.score_accidents[&#39;lat_long&#39;] = (list(self.score_accidents[[&#39;latitude&#39;, &#39;longitude&#39;]]
                                             .itertuples(index=False, name=None)))
    self.sections_df = self._gen_sections()
    self.route_df = self.coor_df[[&#39;origin_tuple&#39;, &#39;destination_tuple&#39;, &#39;sections&#39;]]
    self.final_rank_sections = self._rank_subsections(self.sections_df, flag=&#39;point&#39;)
    self.final_rank_route = self._rank_subsections(self.coor_df, flag=&#39;route&#39;)
    self._calculate_final_score()
    print(f&#39;The final route score is {self.score:.2f}.&#39;)
    if save_map:
        print(&#39;Plotting route and final score on map...&#39;)
        self._plot_final_score()
        self._plot_route_score()
    return self.final_rank_sections</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="safety_road_mapping" href="index.html">safety_road_mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="safety_road_mapping.safety.generate_base_map" href="#safety_road_mapping.safety.generate_base_map">generate_base_map</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="safety_road_mapping.safety.SafetyMap" href="#safety_road_mapping.safety.SafetyMap">SafetyMap</a></code></h4>
<ul class="">
<li><code><a title="safety_road_mapping.safety.SafetyMap._add_route_to_map" href="#safety_road_mapping.safety.SafetyMap._add_route_to_map">_add_route_to_map</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._calculate_final_score" href="#safety_road_mapping.safety.SafetyMap._calculate_final_score">_calculate_final_score</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._calculate_score_weight" href="#safety_road_mapping.safety.SafetyMap._calculate_score_weight">_calculate_score_weight</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._classes_accidents" href="#safety_road_mapping.safety.SafetyMap._classes_accidents">_classes_accidents</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._days_from_accident" href="#safety_road_mapping.safety.SafetyMap._days_from_accident">_days_from_accident</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._filter_accident_data" href="#safety_road_mapping.safety.SafetyMap._filter_accident_data">_filter_accident_data</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._gen_coordinates_df" href="#safety_road_mapping.safety.SafetyMap._gen_coordinates_df">_gen_coordinates_df</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._gen_sections" href="#safety_road_mapping.safety.SafetyMap._gen_sections">_gen_sections</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._getcolor" href="#safety_road_mapping.safety.SafetyMap._getcolor">_getcolor</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._haversine" href="#safety_road_mapping.safety.SafetyMap._haversine">_haversine</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._normalize_string" href="#safety_road_mapping.safety.SafetyMap._normalize_string">_normalize_string</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._plot_final_score" href="#safety_road_mapping.safety.SafetyMap._plot_final_score">_plot_final_score</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._plot_route_score" href="#safety_road_mapping.safety.SafetyMap._plot_route_score">_plot_route_score</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._rank_subsections" href="#safety_road_mapping.safety.SafetyMap._rank_subsections">_rank_subsections</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap._treat_accidents_data" href="#safety_road_mapping.safety.SafetyMap._treat_accidents_data">_treat_accidents_data</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap.format_duration" href="#safety_road_mapping.safety.SafetyMap.format_duration">format_duration</a></code></li>
<li><code><a title="safety_road_mapping.safety.SafetyMap.path_risk_score" href="#safety_road_mapping.safety.SafetyMap.path_risk_score">path_risk_score</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>